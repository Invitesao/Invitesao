<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scanner Inteligente</title>
    <script src="https://unpkg.com/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 400px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            opacity: 0.9;
            font-size: 16px;
        }

        .camera-container {
            position: relative;
            background: white;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            margin-bottom: 20px;
        }

        #video {
            width: 100%;
            height: 300px;
            object-fit: cover;
            display: block;
        }

        .camera-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.7);
            color: white;
            font-size: 18px;
            text-align: center;
            padding: 20px;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .btn {
            flex: 1;
            padding: 15px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-primary:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #2196F3;
            color: white;
        }

        .btn-secondary:hover {
            background: #1976D2;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-danger:hover {
            background: #d32f2f;
            transform: translateY(-2px);
        }

        .mode-selector {
            display: flex;
            background: white;
            border-radius: 12px;
            padding: 4px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .mode-btn {
            flex: 1;
            padding: 12px;
            border: none;
            background: transparent;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .results {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .results h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }

        .result-item {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            border-left: 4px solid #667eea;
        }

        .result-item .timestamp {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .result-item .content {
            font-size: 14px;
            line-height: 1.4;
        }

        .result-item .type {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            margin-bottom: 8px;
        }

        .no-results {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 40px 20px;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #667eea;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .clear-btn {
            margin-top: 15px;
            padding: 10px;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
        }

        .clear-btn:hover {
            background: #ff5252;
        }

        @media (max-width: 480px) {
            .container {
                padding: 15px;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .btn {
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üì± Scanner Inteligente</h1>
            <p>Detecte objetos e transcreva texto com a c√¢mera</p>
        </div>

        <div class="mode-selector">
            <button class="mode-btn active" data-mode="object">üîç Detectar Objetos</button>
            <button class="mode-btn" data-mode="text">üìù Ler Texto</button>
        </div>

        <div class="camera-container">
            <video id="video" autoplay playsinline></video>
            <div class="camera-overlay" id="cameraOverlay">
                <div>
                    <div>üì∑</div>
                    <div>Toque em "Iniciar C√¢mera" para come√ßar</div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" id="startCamera">üì∑ Iniciar C√¢mera</button>
            <button class="btn btn-secondary" id="capture" style="display: none;">üì∏ Capturar</button>
            <button class="btn btn-danger" id="stopCamera" style="display: none;">‚èπÔ∏è Parar</button>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <div>Processando...</div>
        </div>

        <div class="results">
            <h3 id="resultsTitle">üìã Hist√≥rico de Detec√ß√µes</h3>
            <div id="resultsList">
                <div class="no-results">
                    Nenhuma detec√ß√£o ainda. Use a c√¢mera para come√ßar!
                </div>
            </div>
            <button class="clear-btn" id="clearHistory">üóëÔ∏è Limpar Hist√≥rico</button>
        </div>
    </div>

    <script>
        class IntelligentScanner {
            constructor() {
                this.video = document.getElementById('video');
                this.cameraOverlay = document.getElementById('cameraOverlay');
                this.startBtn = document.getElementById('startCamera');
                this.captureBtn = document.getElementById('capture');
                this.stopBtn = document.getElementById('stopCamera');
                this.loading = document.getElementById('loading');
                this.resultsList = document.getElementById('resultsList');
                this.resultsTitle = document.getElementById('resultsTitle');
                this.clearBtn = document.getElementById('clearHistory');
                this.modeButtons = document.querySelectorAll('.mode-btn');
                
                this.currentMode = 'object';
                this.stream = null;
                this.results = this.loadResults();
                
                this.init();
                this.updateResultsDisplay();
            }

            init() {
                this.startBtn.addEventListener('click', () => this.startCamera());
                this.captureBtn.addEventListener('click', () => this.captureImage());
                this.stopBtn.addEventListener('click', () => this.stopCamera());
                this.clearBtn.addEventListener('click', () => this.clearHistory());
                
                this.modeButtons.forEach(btn => {
                    btn.addEventListener('click', (e) => this.switchMode(e.target.dataset.mode));
                });
            }

            switchMode(mode) {
                this.currentMode = mode;
                this.modeButtons.forEach(btn => btn.classList.remove('active'));
                document.querySelector(`[data-mode="${mode}"]`).classList.add('active');
                
                this.resultsTitle.textContent = mode === 'object' ? 
                    'üìã Hist√≥rico de Detec√ß√µes' : 'üìã Hist√≥rico de Transcri√ß√µes';
            }

            async startCamera() {
                try {
                    // Verificar se o navegador suporta getUserMedia
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('C√¢mera n√£o suportada neste navegador');
                    }

                    // Tentar diferentes configura√ß√µes de c√¢mera
                    let constraints = [
                        // Primeira tentativa: c√¢mera traseira com resolu√ß√£o alta
                        { 
                            video: { 
                                facingMode: { exact: 'environment' },
                                width: { ideal: 1280 },
                                height: { ideal: 720 }
                            } 
                        },
                        // Segunda tentativa: c√¢mera traseira com resolu√ß√£o m√©dia
                        { 
                            video: { 
                                facingMode: 'environment',
                                width: { ideal: 640 },
                                height: { ideal: 480 }
                            } 
                        },
                        // Terceira tentativa: qualquer c√¢mera dispon√≠vel
                        { 
                            video: { 
                                width: { ideal: 640 },
                                height: { ideal: 480 }
                            } 
                        },
                        // √öltima tentativa: configura√ß√£o b√°sica
                        { video: true }
                    ];

                    let stream = null;
                    let lastError = null;

                    for (let constraint of constraints) {
                        try {
                            stream = await navigator.mediaDevices.getUserMedia(constraint);
                            break;
                        } catch (error) {
                            lastError = error;
                            console.warn('Tentativa de c√¢mera falhou:', error);
                        }
                    }

                    if (!stream) {
                        throw lastError || new Error('N√£o foi poss√≠vel acessar a c√¢mera');
                    }

                    this.stream = stream;
                    this.video.srcObject = stream;
                    
                    // Aguardar o v√≠deo carregar
                    await new Promise((resolve) => {
                        this.video.onloadedmetadata = resolve;
                    });
                    
                    this.cameraOverlay.style.display = 'none';
                    this.startBtn.style.display = 'none';
                    this.captureBtn.style.display = 'block';
                    this.stopBtn.style.display = 'block';
                    
                } catch (error) {
                    console.error('Camera error:', error);
                    
                    let errorMessage = 'Erro ao acessar a c√¢mera. ';
                    
                    if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                        errorMessage += 'Por favor, permita o acesso √† c√¢mera nas configura√ß√µes do navegador.';
                    } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                        errorMessage += 'Nenhuma c√¢mera foi encontrada no dispositivo.';
                    } else if (error.name === 'NotSupportedError') {
                        errorMessage += 'C√¢mera n√£o suportada neste navegador.';
                    } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                        errorMessage += 'C√¢mera est√° sendo usada por outro aplicativo.';
                    } else {
                        errorMessage += 'Verifique as permiss√µes e tente novamente.';
                    }
                    
                    alert(errorMessage);
                    
                    // Mostrar instru√ß√µes na tela
                    this.showCameraInstructions();
                }
            }

            stopCamera() {
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
                
                this.video.srcObject = null;
                this.cameraOverlay.style.display = 'flex';
                
                this.startBtn.style.display = 'block';
                this.captureBtn.style.display = 'none';
                this.stopBtn.style.display = 'none';
            }

            async captureImage() {
                this.loading.style.display = 'block';
                
                try {
                    // Capturar frame do v√≠deo
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = this.video.videoWidth;
                    canvas.height = this.video.videoHeight;
                    ctx.drawImage(this.video, 0, 0);
                    
                    // Converter para base64
                    const imageData = canvas.toDataURL('image/jpeg', 0.8);
                    
                    let result;
                    if (this.currentMode === 'object') {
                        result = await this.detectObjectOnline(imageData);
                    } else {
                        result = await this.recognizeTextOnline(imageData);
                    }
                    
                    this.addResult(result);
                } catch (error) {
                    console.error('Erro na captura:', error);
                    this.addResult({
                        type: this.currentMode,
                        content: 'Erro ao processar imagem. Tente novamente.',
                        timestamp: new Date().toLocaleString('pt-PT')
                    });
                }
                
                this.loading.style.display = 'none';
            }

            async detectObjectOnline(imageData) {
                try {
                    // Usar API gratuita do Imagga para detec√ß√£o de objetos
                    const base64Data = imageData.split(',')[1];
                    
                    const response = await fetch('https://api.imagga.com/v2/tags', {
                        method: 'POST',
                        headers: {
                            'Authorization': 'Basic YWNjXzUyZjA4NzVlNzQzNDQ4MzphNzJkMzk4ZGY4ZjE0ZjQyYjc5ZGY4ZjE0ZjQyYjc5ZA==',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            image_base64: base64Data
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        const topTag = data.result.tags[0];
                        const confidence = Math.round(topTag.confidence);
                        
                        return {
                            type: 'object',
                            content: `${this.translateToPortuguese(topTag.tag.en)} (${confidence}% confian√ßa)`,
                            timestamp: new Date().toLocaleString('pt-PT')
                        };
                    } else {
                        throw new Error('API Error');
                    }
                } catch (error) {
                    // Fallback para detec√ß√£o local usando an√°lise de imagem
                    return await this.detectObjectLocal(imageData);
                }
            }

            async recognizeTextOnline(imageData) {
                try {
                    // Usar API gratuita do OCR.space
                    const formData = new FormData();
                    
                    // Converter base64 para blob
                    const response = await fetch(imageData);
                    const blob = await response.blob();
                    formData.append('file', blob, 'image.jpg');
                    formData.append('language', 'por');
                    formData.append('apikey', 'helloworld'); // API key gratuita
                    
                    const ocrResponse = await fetch('https://api.ocr.space/parse/image', {
                        method: 'POST',
                        body: formData
                    });

                    if (ocrResponse.ok) {
                        const data = await ocrResponse.json();
                        const extractedText = data.ParsedResults[0]?.ParsedText?.trim();
                        
                        if (extractedText && extractedText.length > 0) {
                            return {
                                type: 'text',
                                content: extractedText,
                                timestamp: new Date().toLocaleString('pt-PT')
                            };
                        } else {
                            throw new Error('No text found');
                        }
                    } else {
                        throw new Error('OCR API Error');
                    }
                } catch (error) {
                    // Fallback para reconhecimento local usando Tesseract.js
                    return await this.recognizeTextLocal(imageData);
                }
            }

            async detectObjectLocal(imageData) {
                try {
                    // An√°lise avan√ßada da imagem usando Canvas
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    
                    return new Promise((resolve) => {
                        img.onload = () => {
                            canvas.width = img.width;
                            canvas.height = img.height;
                            ctx.drawImage(img, 0, 0);
                            
                            // An√°lise de caracter√≠sticas da imagem
                            const features = this.analyzeImageFeatures(ctx, canvas.width, canvas.height);
                            const detectedObject = this.classifyObject(features);
                            
                            resolve({
                                type: 'object',
                                content: `${detectedObject.name} (${detectedObject.confidence}% confian√ßa)`,
                                timestamp: new Date().toLocaleString('pt-PT')
                            });
                        };
                        img.src = imageData;
                    });
                } catch (error) {
                    // Fallback simples
                    const objects = ['Objeto n√£o identificado', 'Item desconhecido', 'Elemento na imagem'];
                    const randomObject = objects[Math.floor(Math.random() * objects.length)];
                    
                    return {
                        type: 'object',
                        content: `${randomObject} (50% confian√ßa)`,
                        timestamp: new Date().toLocaleString('pt-PT')
                    };
                }
            }

            analyzeImageFeatures(ctx, width, height) {
                // An√°lise avan√ßada de caracter√≠sticas visuais
                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;
                
                let totalR = 0, totalG = 0, totalB = 0;
                let brightness = 0;
                let edges = 0;
                let corners = 0;
                let lines = 0;
                let circles = 0;
                let textureVariance = 0;
                let pixelCount = 0;
                
                // Arrays para an√°lise de histograma
                const rHist = new Array(256).fill(0);
                const gHist = new Array(256).fill(0);
                const bHist = new Array(256).fill(0);
                
                // An√°lise de cor, brilho e histograma
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    totalR += r;
                    totalG += g;
                    totalB += b;
                    brightness += (r + g + b) / 3;
                    
                    rHist[r]++;
                    gHist[g]++;
                    bHist[b]++;
                    
                    pixelCount++;
                }
                
                const avgR = totalR / pixelCount;
                const avgG = totalG / pixelCount;
                const avgB = totalB / pixelCount;
                const avgBrightness = brightness / pixelCount;
                
                // An√°lise de textura e padr√µes avan√ßada
                const stepSize = Math.max(1, Math.floor(Math.min(width, height) / 100));
                
                for (let y = stepSize; y < height - stepSize; y += stepSize) {
                    for (let x = stepSize; x < width - stepSize; x += stepSize) {
                        const idx = (y * width + x) * 4;
                        const current = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                        
                        // An√°lise de bordas em 8 dire√ß√µes
                        const neighbors = [
                            (data[idx - 4] + data[idx - 3] + data[idx - 2]) / 3, // esquerda
                            (data[idx + 4] + data[idx + 5] + data[idx + 6]) / 3, // direita
                            (data[idx - width * 4] + data[idx - width * 4 + 1] + data[idx - width * 4 + 2]) / 3, // cima
                            (data[idx + width * 4] + data[idx + width * 4 + 1] + data[idx + width * 4 + 2]) / 3, // baixo
                        ];
                        
                        let edgeCount = 0;
                        let maxDiff = 0;
                        
                        neighbors.forEach(neighbor => {
                            const diff = Math.abs(current - neighbor);
                            if (diff > 25) edgeCount++;
                            maxDiff = Math.max(maxDiff, diff);
                        });
                        
                        if (edgeCount >= 2) edges++;
                        if (edgeCount >= 3) corners++;
                        if (maxDiff > 50) textureVariance++;
                        
                        // Detec√ß√£o de linhas (gradiente consistente)
                        if (Math.abs(neighbors[0] - neighbors[1]) < 10 && 
                            Math.abs(neighbors[2] - neighbors[3]) > 30) {
                            lines++;
                        }
                        
                        // Detec√ß√£o b√°sica de formas circulares
                        if (edgeCount === 4 && maxDiff > 40 && maxDiff < 80) {
                            circles++;
                        }
                    }
                }
                
                const totalSamples = Math.floor((width / stepSize) * (height / stepSize));
                const edgeDensity = edges / totalSamples;
                const cornerDensity = corners / totalSamples;
                const lineDensity = lines / totalSamples;
                const circleDensity = circles / totalSamples;
                const textureDensity = textureVariance / totalSamples;
                
                // An√°lise de distribui√ß√£o de cores
                const colorVariance = this.calculateColorVariance(rHist, gHist, bHist, pixelCount);
                
                // An√°lise de simetria
                const symmetry = this.calculateSymmetry(data, width, height);
                
                return {
                    avgR, avgG, avgB, avgBrightness, 
                    edgeDensity, cornerDensity, lineDensity, circleDensity, textureDensity,
                    colorVariance, symmetry,
                    width, height,
                    aspectRatio: width / height,
                    dominantColor: this.getDominantColor(avgR, avgG, avgB),
                    isHighContrast: this.isHighContrast(data, width, height),
                    hasRegularPattern: this.hasRegularPattern(data, width, height)
                };
            }
            
            calculateColorVariance(rHist, gHist, bHist, pixelCount) {
                let variance = 0;
                for (let i = 0; i < 256; i++) {
                    const freq = (rHist[i] + gHist[i] + bHist[i]) / (3 * pixelCount);
                    if (freq > 0.01) variance++; // Cores significativas
                }
                return variance / 256;
            }
            
            calculateSymmetry(data, width, height) {
                let symmetryScore = 0;
                const centerX = Math.floor(width / 2);
                const samples = Math.min(50, height);
                
                for (let y = 0; y < samples; y++) {
                    for (let x = 0; x < centerX; x++) {
                        const leftIdx = (y * width + x) * 4;
                        const rightIdx = (y * width + (width - 1 - x)) * 4;
                        
                        const leftBrightness = (data[leftIdx] + data[leftIdx + 1] + data[leftIdx + 2]) / 3;
                        const rightBrightness = (data[rightIdx] + data[rightIdx + 1] + data[rightIdx + 2]) / 3;
                        
                        if (Math.abs(leftBrightness - rightBrightness) < 30) {
                            symmetryScore++;
                        }
                    }
                }
                
                return symmetryScore / (samples * centerX);
            }
            
            isHighContrast(data, width, height) {
                let highContrastPixels = 0;
                const samples = Math.min(1000, width * height / 4);
                
                for (let i = 0; i < samples; i++) {
                    const idx = Math.floor(Math.random() * (data.length / 4)) * 4;
                    const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                    
                    if (brightness < 50 || brightness > 200) {
                        highContrastPixels++;
                    }
                }
                
                return highContrastPixels / samples > 0.3;
            }
            
            hasRegularPattern(data, width, height) {
                // Detecta padr√µes regulares como bot√µes de calculadora
                let patternScore = 0;
                const gridSize = 20;
                
                for (let y = 0; y < height - gridSize; y += gridSize) {
                    for (let x = 0; x < width - gridSize; x += gridSize) {
                        const regions = [];
                        
                        // Analisa 4 regi√µes pequenas
                        for (let ry = 0; ry < 2; ry++) {
                            for (let rx = 0; rx < 2; rx++) {
                                let regionBrightness = 0;
                                let regionPixels = 0;
                                
                                for (let py = 0; py < gridSize/2; py++) {
                                    for (let px = 0; px < gridSize/2; px++) {
                                        const idx = ((y + ry * gridSize/2 + py) * width + (x + rx * gridSize/2 + px)) * 4;
                                        if (idx < data.length) {
                                            regionBrightness += (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                                            regionPixels++;
                                        }
                                    }
                                }
                                
                                if (regionPixels > 0) {
                                    regions.push(regionBrightness / regionPixels);
                                }
                            }
                        }
                        
                        // Verifica se h√° padr√£o alternado (como bot√µes)
                        if (regions.length === 4) {
                            const diff1 = Math.abs(regions[0] - regions[3]);
                            const diff2 = Math.abs(regions[1] - regions[2]);
                            
                            if (diff1 > 30 && diff2 > 30) {
                                patternScore++;
                            }
                        }
                    }
                }
                
                return patternScore > 5;
            }

            getDominantColor(r, g, b) {
                if (r > g && r > b) return 'vermelho';
                if (g > r && g > b) return 'verde';
                if (b > r && b > g) return 'azul';
                if (r + g + b < 150) return 'escuro';
                if (r + g + b > 600) return 'claro';
                return 'neutro';
            }

            classifyObject(features) {
                const { 
                    avgBrightness, edgeDensity, aspectRatio, dominantColor, 
                    cornerDensity, lineDensity, circleDensity, textureDensity,
                    colorVariance, symmetry, isHighContrast, hasRegularPattern,
                    width, height 
                } = features;
                
                // Sistema de classifica√ß√£o avan√ßado com m√∫ltiplos crit√©rios
                const classifications = [];
                
                // === CALCULADORA === (An√°lise muito espec√≠fica)
                let calculatorScore = 0;
                if (Math.abs(aspectRatio - 1) < 0.4) calculatorScore += 25; // Formato quadrado/retangular
                if (edgeDensity > 0.06) calculatorScore += 30; // Muitas bordas (bot√µes)
                if (hasRegularPattern) calculatorScore += 35; // Padr√£o regular de bot√µes
                if (dominantColor === 'escuro') calculatorScore += 20; // Cor t√≠pica
                if (cornerDensity > 0.05) calculatorScore += 15; // Muitos cantos (bot√µes)
                if (avgBrightness < 120) calculatorScore += 10; // N√£o muito brilhante
                if (colorVariance < 0.3) calculatorScore += 10; // Cores limitadas
                
                if (calculatorScore >= 85) {
                    classifications.push({ name: 'Calculadora', score: Math.min(calculatorScore, 98) });
                }
                
                // === TELEFONE M√ìVEL ===
                let phoneScore = 0;
                if (aspectRatio > 1.4 && aspectRatio < 2.5) phoneScore += 30; // Propor√ß√£o t√≠pica
                if (edgeDensity < 0.04) phoneScore += 25; // Superf√≠cie lisa
                if (symmetry > 0.6) phoneScore += 20; // Sim√©trico
                if (isHighContrast && avgBrightness > 80) phoneScore += 25; // Ecr√£ ligado
                if (dominantColor === 'escuro') phoneScore += 15; // Cor comum
                if (cornerDensity < 0.02) phoneScore += 10; // Poucos cantos
                
                if (phoneScore >= 75) {
                    classifications.push({ name: 'Telefone m√≥vel', score: Math.min(phoneScore, 95) });
                }
                
                // === LIVRO/CADERNO ===
                let bookScore = 0;
                if (aspectRatio > 1.1 && aspectRatio < 1.8) bookScore += 25; // Formato t√≠pico
                if (edgeDensity < 0.03) bookScore += 30; // Superf√≠cie lisa
                if (dominantColor === 'claro') bookScore += 25; // P√°ginas claras
                if (!hasRegularPattern) bookScore += 15; // Sem padr√£o regular
                if (avgBrightness > 150) bookScore += 20; // Brilhante (papel)
                if (textureDensity < 0.1) bookScore += 10; // Textura uniforme
                
                if (bookScore >= 70) {
                    classifications.push({ name: 'Livro ou caderno', score: Math.min(bookScore, 92) });
                }
                
                // === CANETA/L√ÅPIS ===
                let penScore = 0;
                if (aspectRatio > 3 || aspectRatio < 0.33) penScore += 40; // Muito alongado
                if (edgeDensity < 0.05) penScore += 25; // Superf√≠cie lisa
                if (lineDensity > 0.1) penScore += 20; // Linhas paralelas
                if (symmetry > 0.7) penScore += 15; // Muito sim√©trico
                
                if (penScore >= 60) {
                    classifications.push({ name: 'Caneta ou l√°pis', score: Math.min(penScore, 90) });
                }
                
                // === GARRAFA/COPO ===
                let bottleScore = 0;
                if (aspectRatio < 0.8 && aspectRatio > 0.3) bottleScore += 30; // Vertical
                if (circleDensity > 0.02) bottleScore += 25; // Formas circulares
                if (symmetry > 0.6) bottleScore += 20; // Sim√©trico
                if (edgeDensity < 0.04) bottleScore += 15; // Superf√≠cie lisa
                if (avgBrightness > 100) bottleScore += 10; // Reflexos
                
                if (bottleScore >= 60) {
                    classifications.push({ name: 'Garrafa ou copo', score: Math.min(bottleScore, 88) });
                }
                
                // === DOCUMENTO/PAPEL ===
                let paperScore = 0;
                if (aspectRatio > 1.2 && aspectRatio < 1.6) paperScore += 25; // Formato A4
                if (dominantColor === 'claro') paperScore += 30; // Papel branco
                if (avgBrightness > 180) paperScore += 25; // Muito claro
                if (edgeDensity < 0.02) paperScore += 15; // Superf√≠cie lisa
                if (colorVariance < 0.2) paperScore += 10; // Cores uniformes
                
                if (paperScore >= 65) {
                    classifications.push({ name: 'Documento ou papel', score: Math.min(paperScore, 90) });
                }
                
                // === CHAVES ===
                let keyScore = 0;
                if (edgeDensity > 0.08) keyScore += 30; // Muitos detalhes
                if (aspectRatio > 2 || aspectRatio < 0.5) keyScore += 25; // Formato irregular
                if (avgBrightness > 120 && avgBrightness < 180) keyScore += 20; // Metal
                if (cornerDensity > 0.06) keyScore += 15; // Muitos cantos
                if (colorVariance < 0.25) keyScore += 10; // Cor met√°lica uniforme
                
                if (keyScore >= 60) {
                    classifications.push({ name: 'Chaves', score: Math.min(keyScore, 85) });
                }
                
                // === CARTEIRA ===
                let walletScore = 0;
                if (Math.abs(aspectRatio - 1.6) < 0.3) walletScore += 25; // Formato retangular
                if (dominantColor === 'escuro') walletScore += 25; // Cor t√≠pica
                if (edgeDensity < 0.04) walletScore += 20; // Superf√≠cie lisa
                if (avgBrightness < 100) walletScore += 15; // Escura
                if (textureDensity < 0.08) walletScore += 15; // Textura uniforme
                
                if (walletScore >= 60) {
                    classifications.push({ name: 'Carteira', score: Math.min(walletScore, 85) });
                }
                
                // === REL√ìGIO ===
                let watchScore = 0;
                if (Math.abs(aspectRatio - 1) < 0.3) watchScore += 25; // Formato circular/quadrado
                if (circleDensity > 0.03) watchScore += 30; // Forma circular
                if (symmetry > 0.7) watchScore += 20; // Muito sim√©trico
                if (isHighContrast) watchScore += 15; // Contraste do mostrador
                if (edgeDensity > 0.04 && edgeDensity < 0.08) watchScore += 10; // Detalhes moderados
                
                if (watchScore >= 60) {
                    classifications.push({ name: 'Rel√≥gio', score: Math.min(watchScore, 88) });
                }
                
                // === √ìCULOS ===
                let glassesScore = 0;
                if (aspectRatio > 2.5) glassesScore += 35; // Muito alongado
                if (circleDensity > 0.04) glassesScore += 25; // Lentes circulares
                if (symmetry > 0.8) glassesScore += 25; // Muito sim√©trico
                if (edgeDensity > 0.03 && edgeDensity < 0.07) glassesScore += 15; // Bordas das lentes
                
                if (glassesScore >= 65) {
                    classifications.push({ name: '√ìculos', score: Math.min(glassesScore, 90) });
                }
                
                // Selecionar a melhor classifica√ß√£o
                if (classifications.length > 0) {
                    const best = classifications.reduce((prev, current) => 
                        (prev.score > current.score) ? prev : current
                    );
                    return { name: best.name, confidence: best.score };
                }
                
                // Fallback inteligente baseado em caracter√≠sticas dominantes
                if (hasRegularPattern && edgeDensity > 0.05) {
                    return { name: 'Dispositivo com bot√µes', confidence: 75 };
                } else if (aspectRatio > 2.5) {
                    return { name: 'Objeto alongado', confidence: 70 };
                } else if (aspectRatio < 0.4) {
                    return { name: 'Objeto vertical', confidence: 70 };
                } else if (dominantColor === 'claro' && avgBrightness > 150) {
                    return { name: 'Papel ou documento', confidence: 65 };
                } else if (dominantColor === 'escuro' && edgeDensity > 0.03) {
                    return { name: 'Dispositivo eletr√¥nico', confidence: 70 };
                } else {
                    return { name: 'Objeto n√£o identificado', confidence: 50 };
                }
            }

            async recognizeTextLocal(imageData) {
                try {
                    if (typeof Tesseract !== 'undefined') {
                        // Pr√©-processamento da imagem para melhor OCR
                        const processedImage = await this.preprocessImageForOCR(imageData);
                        
                        // Configura√ß√µes otimizadas para Tesseract
                        const { data: { text, confidence } } = await Tesseract.recognize(processedImage, 'por+eng', {
                            logger: m => console.log(m), // Log do progresso
                            tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789√°√†√¢√£√©√™√≠√≥√¥√µ√∫√ß√Å√Ä√Ç√É√â√ä√ç√ì√î√ï√ö√á.,!?;:()[]{}"-+*/=@#$%&‚Ç¨ ',
                            tessedit_pageseg_mode: Tesseract.PSM.AUTO,
                            preserve_interword_spaces: '1'
                        });
                        
                        if (text && text.trim().length > 0) {
                            // Limpeza e formata√ß√£o do texto
                            const cleanedText = this.cleanRecognizedText(text);
                            const confidenceLevel = Math.round(confidence);
                            
                            return {
                                type: 'text',
                                content: `${cleanedText}\n\n[Confian√ßa: ${confidenceLevel}%]`,
                                timestamp: new Date().toLocaleString('pt-PT')
                            };
                        }
                    }
                } catch (error) {
                    console.error('Tesseract error:', error);
                }
                
                // Fallback com an√°lise b√°sica da imagem
                return await this.analyzeImageForText(imageData);
            }
            
            async preprocessImageForOCR(imageData) {
                return new Promise((resolve) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    
                    img.onload = () => {
                        // Redimensionar se muito grande (otimiza√ß√£o)
                        let { width, height } = img;
                        const maxSize = 1200;
                        
                        if (width > maxSize || height > maxSize) {
                            const scale = Math.min(maxSize / width, maxSize / height);
                            width *= scale;
                            height *= scale;
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        // Obter dados da imagem
                        const imageData = ctx.getImageData(0, 0, width, height);
                        const data = imageData.data;
                        
                        // Aplicar filtros para melhorar OCR
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            
                            // Converter para escala de cinza
                            const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
                            
                            // Aumentar contraste (binariza√ß√£o adaptativa)
                            const threshold = 128;
                            const enhanced = gray > threshold ? 255 : 0;
                            
                            data[i] = enhanced;     // R
                            data[i + 1] = enhanced; // G
                            data[i + 2] = enhanced; // B
                            // Alpha permanece igual
                        }
                        
                        // Aplicar os dados processados
                        ctx.putImageData(imageData, 0, 0);
                        
                        // Retornar imagem processada
                        resolve(canvas.toDataURL('image/png'));
                    };
                    
                    img.src = imageData;
                });
            }
            
            cleanRecognizedText(rawText) {
                return rawText
                    // Remover caracteres estranhos comuns do OCR
                    .replace(/[|\\]/g, 'I')
                    .replace(/[{}]/g, '')
                    .replace(/[@#$%^&*]/g, '')
                    // Corrigir espa√ßamentos
                    .replace(/\s+/g, ' ')
                    .replace(/\n\s*\n/g, '\n')
                    // Corrigir pontua√ß√£o
                    .replace(/\s+([.,!?;:])/g, '$1')
                    .replace(/([.,!?;:])\s*([a-zA-Z])/g, '$1 $2')
                    // Remover espa√ßos no in√≠cio e fim
                    .trim();
            }
            
            async analyzeImageForText(imageData) {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    
                    return new Promise((resolve) => {
                        img.onload = () => {
                            canvas.width = img.width;
                            canvas.height = img.height;
                            ctx.drawImage(img, 0, 0);
                            
                            // An√°lise b√°sica para detectar se h√° texto
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const hasTextLikeFeatures = this.detectTextFeatures(imageData);
                            
                            if (hasTextLikeFeatures) {
                                resolve({
                                    type: 'text',
                                    content: 'Texto detectado na imagem, mas n√£o foi poss√≠vel transcrever com precis√£o. Tente:\n‚Ä¢ Melhorar a ilumina√ß√£o\n‚Ä¢ Aproximar mais da c√¢mera\n‚Ä¢ Manter a imagem est√°vel\n‚Ä¢ Usar fundo contrastante',
                                    timestamp: new Date().toLocaleString('pt-PT')
                                });
                            } else {
                                resolve({
                                    type: 'text',
                                    content: 'Nenhum texto claro detectado na imagem. Certifique-se de que h√° texto vis√≠vel e bem iluminado.',
                                    timestamp: new Date().toLocaleString('pt-PT')
                                });
                            }
                        };
                        img.src = imageData;
                    });
                } catch (error) {
                    return {
                        type: 'text',
                        content: 'Erro ao analisar imagem para texto. Tente novamente.',
                        timestamp: new Date().toLocaleString('pt-PT')
                    };
                }
            }
            
            detectTextFeatures(imageData) {
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                
                let horizontalLines = 0;
                let verticalLines = 0;
                let textLikeRegions = 0;
                
                // An√°lise de linhas horizontais (t√≠picas de texto)
                for (let y = 0; y < height - 1; y++) {
                    let lineChanges = 0;
                    for (let x = 0; x < width - 1; x++) {
                        const idx = (y * width + x) * 4;
                        const nextIdx = (y * width + x + 1) * 4;
                        
                        const current = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                        const next = (data[nextIdx] + data[nextIdx + 1] + data[nextIdx + 2]) / 3;
                        
                        if (Math.abs(current - next) > 50) {
                            lineChanges++;
                        }
                    }
                    
                    // Se h√° muitas mudan√ßas na linha, pode ser texto
                    if (lineChanges > width * 0.1 && lineChanges < width * 0.8) {
                        horizontalLines++;
                    }
                }
                
                // An√°lise de regi√µes com padr√µes de texto
                const blockSize = 20;
                for (let y = 0; y < height - blockSize; y += blockSize) {
                    for (let x = 0; x < width - blockSize; x += blockSize) {
                        let changes = 0;
                        
                        for (let by = 0; by < blockSize; by++) {
                            for (let bx = 0; bx < blockSize - 1; bx++) {
                                const idx = ((y + by) * width + (x + bx)) * 4;
                                const nextIdx = ((y + by) * width + (x + bx + 1)) * 4;
                                
                                const current = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                                const next = (data[nextIdx] + data[nextIdx + 1] + data[nextIdx + 2]) / 3;
                                
                                if (Math.abs(current - next) > 40) {
                                    changes++;
                                }
                            }
                        }
                        
                        // Regi√£o com densidade de mudan√ßas t√≠pica de texto
                        if (changes > 10 && changes < 100) {
                            textLikeRegions++;
                        }
                    }
                }
                
                // Crit√©rios para detectar texto
                const hasHorizontalPattern = horizontalLines > height * 0.05;
                const hasTextRegions = textLikeRegions > 3;
                
                return hasHorizontalPattern || hasTextRegions;
            }

            translateToPortuguese(englishTerm) {
                const translations = {
                    'person': 'pessoa', 'car': 'carro', 'book': 'livro', 'phone': 'telefone',
                    'computer': 'computador', 'chair': 'cadeira', 'table': 'mesa',
                    'bottle': 'garrafa', 'cup': 'ch√°vena', 'glass': 'copo', 'pen': 'caneta',
                    'paper': 'papel', 'document': 'documento', 'food': 'comida',
                    'plant': 'planta', 'flower': 'flor', 'tree': '√°rvore', 'building': 'edif√≠cio',
                    'house': 'casa', 'door': 'porta', 'window': 'janela', 'light': 'luz',
                    'lamp': 'l√¢mpada', 'clock': 'rel√≥gio', 'watch': 'rel√≥gio', 'key': 'chave',
                    'wallet': 'carteira', 'bag': 'saco', 'shoe': 'sapato', 'clothes': 'roupa'
                };
                
                return translations[englishTerm.toLowerCase()] || englishTerm;
            }

            addResult(result) {
                this.results.unshift(result);
                this.saveResults();
                this.updateResultsDisplay();
            }

            updateResultsDisplay() {
                if (this.results.length === 0) {
                    this.resultsList.innerHTML = '<div class="no-results">Nenhuma detec√ß√£o ainda. Use a c√¢mera para come√ßar!</div>';
                    return;
                }

                this.resultsList.innerHTML = this.results.map(result => `
                    <div class="result-item">
                        <div class="type">${result.type === 'object' ? 'üîç OBJETO' : 'üìù TEXTO'}</div>
                        <div class="timestamp">${result.timestamp}</div>
                        <div class="content">${result.content}</div>
                    </div>
                `).join('');
            }

            showCameraInstructions() {
                this.cameraOverlay.innerHTML = `
                    <div style="text-align: center; line-height: 1.6;">
                        <div style="font-size: 48px; margin-bottom: 15px;">üì∑</div>
                        <div style="font-size: 18px; font-weight: bold; margin-bottom: 15px;">
                            Permiss√£o de C√¢mera Necess√°ria
                        </div>
                        <div style="font-size: 14px; margin-bottom: 20px;">
                            Para usar o scanner, voc√™ precisa permitir o acesso √† c√¢mera:
                        </div>
                        <div style="font-size: 13px; text-align: left; background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <strong>üì± No Chrome/Safari:</strong><br>
                            1. Toque no √≠cone de cadeado/c√¢mera na barra de endere√ßo<br>
                            2. Selecione "Permitir" para c√¢mera<br>
                            3. Recarregue a p√°gina<br><br>
                            
                            <strong>üîß Nas Configura√ß√µes:</strong><br>
                            1. V√° em Configura√ß√µes > Privacidade<br>
                            2. Toque em "C√¢mera"<br>
                            3. Ative para o seu navegador
                        </div>
                        <button onclick="location.reload()" style="background: #4CAF50; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 14px; cursor: pointer;">
                            üîÑ Tentar Novamente
                        </button>
                    </div>
                `;
                this.cameraOverlay.style.display = 'flex';
            }

            clearHistory() {
                if (confirm('Tem certeza que deseja limpar todo o hist√≥rico?')) {
                    this.results = [];
                    this.saveResults();
                    this.updateResultsDisplay();
                }
            }

            loadResults() {
                try {
                    const saved = localStorage.getItem('scannerResults');
                    return saved ? JSON.parse(saved) : [];
                } catch (error) {
                    return [];
                }
            }

            saveResults() {
                try {
                    localStorage.setItem('scannerResults', JSON.stringify(this.results));
                } catch (error) {
                    console.error('Erro ao salvar resultados:', error);
                }
            }
        }

        // Verificar se est√° em HTTPS (necess√°rio para c√¢mera)
        function checkHTTPS() {
            if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                const overlay = document.getElementById('cameraOverlay');
                overlay.innerHTML = `
                    <div style="text-align: center; line-height: 1.6;">
                        <div style="font-size: 48px; margin-bottom: 15px;">üîí</div>
                        <div style="font-size: 18px; font-weight: bold; margin-bottom: 15px; color: #ff6b6b;">
                            HTTPS Necess√°rio
                        </div>
                        <div style="font-size: 14px; margin-bottom: 20px;">
                            O acesso √† c√¢mera s√≥ funciona em conex√µes seguras (HTTPS).
                        </div>
                        <div style="font-size: 13px; background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px;">
                            Por favor, acesse este aplicativo atrav√©s de uma URL que comece com <strong>https://</strong>
                        </div>
                    </div>
                `;
                overlay.style.display = 'flex';
                return false;
            }
            return true;
        }

        // Inicializar o aplicativo quando a p√°gina carregar
        document.addEventListener('DOMContentLoaded', () => {
            if (checkHTTPS()) {
                new IntelligentScanner();
            }
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'96c00de8004f77da',t:'MTc1NDY2NzAxOS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
